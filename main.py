#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Nov 29 20:28:00 2024

@author: tanouiramari
"""

import math
from sympy import isprime, factorint, Matrix, mod_inverse
import random

# Parameters
p = 10930889  # Modulus
alpha = 2317547  # Generator of the subgroup
order = 59407  # Order of the subgroup generated by alpha
factor_base_bound = 1000  # Bound for factor base generation

# Step 1: Generate the factor base
def generate_factor_base(bound):
    """
    Generates a factor base (a list of primes) up to a given bound.

    Args:
    - bound (int): The upper bound for generating prime numbers.

    Returns:
    - list of int: A list of primes less than or equal to `bound`.
    """
    return [n for n in range(2, bound + 1) if isprime(n)]

# Step 2: Check if a number is B-smooth
def is_b_smooth(value, factor_base):
    """
    Checks if a number is B-smooth, meaning it can be entirely factored in terms of the elements of the factor base.

    Args:
    - value (int): The number to be tested.
    - factor_base (list of int): The factor base used for factorization.

    Returns:
    - bool: True if the number is B-smooth, otherwise False.
    - dict: The factorization of the number (prime factors and their exponents).
    """
    factorization = {}
    for prime in factor_base:
        exponent = 0
        while value % prime == 0:
            value //= prime
            exponent += 1
        if exponent > 0:
            factorization[prime] = exponent
    if value != 1:
        return False, {}
    return True, factorization

# Step 3: Generate a B-smooth beta
def generate_b_smooth_beta(alpha, p, factor_base, max_attempts=100):
    """
    Generates a B-smooth beta by finding an exponent k such that alpha^k mod p is B-smooth.

    Args:
    - alpha (int): The generator of the subgroup.
    - p (int): The modulus.
    - factor_base (list of int): The factor base.
    - max_attempts (int): The maximum number of attempts to generate a B-smooth beta.

    Returns:
    - tuple: The B-smooth beta and its factorization if found, otherwise None.
    """
    for _ in range(max_attempts):
        k = random.randint(1, order - 1)  # Random exponent
        beta = pow(alpha, k, p)  # Calculate alpha^k mod p
        is_smooth, factorization = is_b_smooth(beta, factor_base)
        if is_smooth:
            return beta, factorization  # Return the B-smooth beta and its factorization
    return None, None  # If no B-smooth beta is found after several attempts

# Step 4: Find relations by checking B-smoothness
def find_relations(alpha, p, factor_base, max_exponent):
    """
    Finds relations by calculating powers of alpha mod p and checking for B-smoothness.

    Args:
    - alpha (int): The element generator of the subgroup.
    - p (int): The modulus.
    - factor_base (list of int): The factor base.
    - max_exponent (int): The maximum exponent to consider.

    Returns:
    - list of dict: List of relations (factorizations).
    - list of int: Corresponding exponents.
    """
    relations = []
    exponents = []

    for k in range(1, max_exponent + 1):
        # Ensure that k is within the valid range for the subgroup
        k = k % order  # Take exponent modulo the order of the subgroup
        value = pow(alpha, k, p)  # Calculate alpha^k mod p
        is_smooth, factorization = is_b_smooth(value, factor_base)
        if is_smooth:
            relations.append(factorization)
            exponents.append(k)
    
    return relations, exponents

# Step 5: Solve the linear system (modular arithmetic with the subgroup order)
def solve_linear_system(relations, exponents, factor_base, order):
    """
    Solves the system of linear equations based on the relations found.

    Args:
    - relations (list of dict): The relations obtained.
    - exponents (list of int): The exponents associated with the relations.
    - factor_base (list of int): The factor base.
    - order (int): The order of the subgroup.

    Returns:
    - list: Logarithms of the elements in the factor base.
    """
    # Construct the matrix for the system
    matrix = []
    for relation, exp in zip(relations, exponents):
        # Construct each row for the matrix
        row = [relation.get(f, 0) for f in factor_base] + [exp]
        matrix.append(row)
    print(matrix)
    # Convert the matrix into a sympy Matrix and apply modulo
    matrix_mod = Matrix(matrix).applyfunc(lambda x: x % order)
    
    # Perform row reduction to solve the system
    reduced_matrix, pivot_columns = matrix_mod.rref(iszerofunc=lambda x: x % order == 0)

    # Extract the logarithms (solutions)
    logs = []
    num_rows, num_cols = reduced_matrix.shape
    for i in range(num_rows):
        logs.append(reduced_matrix[i, -1] % order)
    
    return logs

# Step 6: Calculate base log beta
def calculate_discrete_log(beta_factors, base_logs):
    """
    Calculate the discrete logarithm of β by using its prime factorization and the base logarithms.

    This function computes log_β using the relation:
    log_β = Σ (exponent of prime * log(prime)), for each prime factor of β.
    
    Args:
    - beta_factors (dict): Prime factors of β with their exponents.
    - base_logs (dict): Logarithms of the prime factors of the base.

    Returns:
    - float: The discrete logarithm of β.

    
    """
    log_beta = 0
    for prime, exponent in beta_factors.items():
        if prime in base_logs:
            log_beta += exponent * base_logs[prime]
        else:
            raise ValueError(f"Logarithm of prime {prime} not found in the base logs.")
    return log_beta


# Main function to tie everything together
def main():
    # Step 1: Generate the factor base
    factor_base = generate_factor_base(factor_base_bound)
    
    # Step 2: Generate a B-smooth beta
    beta, factorization = generate_b_smooth_beta(alpha, p, factor_base)
    if beta is not None:
        print(f"B-smooth beta: {beta}")
        print(f"Factorization: {factorization}")
    else:
        print("No B-smooth beta found after several attempts.")

    # Step 3: Find relations
    max_exponent = 100
    relations, exponents = find_relations(alpha, p, factor_base, max_exponent)
    
    # Step 4: Display the relations
    for k, relation in zip(exponents, relations):
        print(f"k = {k}: alpha^{k} mod {p} = {relation}")

    # Step 5: Solve the linear system
    logs = solve_linear_system(relations, exponents, factor_base, order)
    print(f"Logs: {logs}")
    
    

# Run the main function
if __name__ == "__main__":
    main()
